{"version":3,"file":"chunks/59171.183eda480da0435933f1.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/context_menu.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/image-figure.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/focus-handler.js"],"sourcesContent":["import registry from \"@patternslib/patternslib/src/core/registry\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport patTooltip from \"@patternslib/patternslib/src/pat/tooltip/tooltip\";\nimport { posToDOMRect } from \"@tiptap/core\";\n\nlet PREV_NODE = null;\n\nexport async function context_menu({\n    url,\n    editor,\n    instance = null,\n    pattern = null,\n    extra_class = null,\n}) {\n    const prev_node = PREV_NODE;\n    const cur_node = (PREV_NODE = editor.state.doc.nodeAt(editor.state.selection.from));\n\n    if (\n        instance !== null &&\n        (cur_node !== prev_node || !instance?.tippy.popperInstance)\n    ) {\n        // Close context menu, when new node is selected.\n        await context_menu_close({\n            instance: instance,\n            pattern_name: pattern.name,\n        });\n        instance = null;\n    }\n\n    if (!instance || !instance?.tippy.popperInstance) {\n        // Only re-initialize when not already opened.\n\n        // 1) Dynamically register a pattern to be used in the context menu\n        //    We need to unregister it after use in ``context_menu_close``\n        //    to allow multiple tiptap editors on the same page because it\n        //    references the current editor instance.\n        if (pattern) {\n            registry.patterns[pattern.name] = pattern;\n        }\n\n        // 2) Initialize the tooltip\n        const editor_element = editor.options.element;\n        instance = await new patTooltip(editor_element, {\n            \"source\": \"ajax\",\n            \"url\": url,\n            \"trigger\": \"none\",\n            \"class\": extra_class,\n            \"position-list\": [\"tl\"],\n        });\n\n        await events.await_pattern_init(instance);\n\n        const reference_position = posToDOMRect(\n            editor.view,\n            editor.state.selection.from,\n            editor.state.selection.to\n        );\n\n        instance.tippy?.setProps({\n            // NOTE: getReferenceClientRect is called after each setContent.\n            getReferenceClientRect: () => reference_position,\n        });\n\n        events.add_event_listener(\n            document,\n            \"mousedown\",\n            \"tiptap--context_menu_close--click\",\n            async (e) => {\n                if (\n                    [e.target, ...dom.get_parents(e.target)].includes(\n                        instance?.tippy.popper\n                    )\n                ) {\n                    // Do not close the context menu if we click in it.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n        events.add_event_listener(\n            document,\n            \"keydown\",\n            \"tiptap--context_menu_close--esc\",\n            async (e) => {\n                if (e.key !== \"Escape\") {\n                    // Not a closing key.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n\n        instance.show();\n    } else {\n        instance.get_content(url);\n    }\n\n    return instance;\n}\n\nexport async function context_menu_close({ instance, pattern_name }) {\n    // Hide and destroy the context menu / tooltip instance\n    if (instance) {\n        await instance.hide();\n        instance.destroy();\n        instance = null;\n    }\n\n    // Unregister the pattern\n    if (pattern_name) {\n        delete registry.patterns[pattern_name];\n    }\n    events.remove_event_listener(document, \"tiptap--context_menu_close--click\");\n    events.remove_event_listener(document, \"tiptap--context_menu_close--esc\");\n    return null;\n}\n","import { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport { Node, mergeAttributes } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\nimport { BasePattern } from \"@patternslib/patternslib/src/core/basepattern\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nlet context_menu_instance;\n\nfunction pattern_image_context_menu({ app: app }) {\n    class Pattern extends BasePattern {\n        static name = \"tiptap-image-context-menu\";\n        static trigger = \".tiptap-image-context-menu\";\n\n        init() {\n            focus_handler(this.el);\n\n            const btn_edit = this.el.querySelector(\".tiptap-edit-image\");\n            const btn_remove = this.el.querySelector(\".tiptap-remove-image\");\n\n            btn_edit &&\n                btn_edit.addEventListener(\"click\", () => {\n                    app.toolbar.image.click();\n                });\n\n            btn_remove &&\n                btn_remove.addEventListener(\"click\", () => {\n                    app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n                    app.editor.commands.deleteSelection();\n                    app.editor.commands.focus();\n                });\n        }\n    }\n\n    return Pattern;\n}\n\nfunction image_panel({ app }) {\n    // Not Base-pattern based due to two reasons:\n    // - We need to reinitialize the pattern on already initialized nodes on possible tab-changes within the modal.\n    // - We need to keep the _node_image and _figcaption references among re-initializations.\n    return {\n        name: \"tiptap-image-panel\",\n        trigger: app.options.image?.panel,\n\n        init(image_panel) {\n            const image_srcs = image_panel.querySelectorAll(\"[name=tiptap-src]\");\n            const image_alt = image_panel.querySelector(\"[name=tiptap-alt]\");\n            const image_title = image_panel.querySelector(\"[name=tiptap-title]\");\n            const image_caption = image_panel.querySelector(\"[name=tiptap-caption]\");\n            const image_confirm = image_panel.querySelector(\".tiptap-confirm, [name=tiptap-confirm]\"); // prettier-ignore\n            focus_handler(image_panel);\n\n            const node_image = this.node_image;\n\n            // Populate form fields\n            if (node_image) {\n                const current_src = node_image.attrs?.src;\n                // Filter for all inputs with the same src value but not an empty src.\n                let image_srcs_ = current_src\n                    ? [...image_srcs].filter((it) => it.value === current_src)\n                    : [];\n                if (image_srcs_.length > 0) {\n                    for (const image_src of image_srcs_) {\n                        image_src.checked = true;\n                        image_src.dispatchEvent(events.change_event());\n                    }\n                } else {\n                    let image_srcs_ = [...image_srcs].filter(\n                        (it) => it.type === \"text\" || it.type === \"url\"\n                    );\n                    if (image_srcs_.length > 0 && !image_srcs_[0].value) {\n                        image_srcs_[0].value = current_src || \"\";\n                    }\n                }\n                if (image_title && !image_title.value) {\n                    image_title.value = node_image.attrs?.title || \"\";\n                }\n                if (image_alt && !image_alt.value) {\n                    image_alt.value = node_image.attrs?.alt || \"\";\n                }\n            }\n\n            // Get / set figcaption node, if it exists\n            const node_figcaption = this.figcaption_node;\n            if (node_figcaption && image_caption && !image_caption.value) {\n                image_caption.value = node_figcaption.textContent || \"\";\n            }\n\n            const update_callback = (set_focus) => {\n                // Get the selected image on time of submitting\n                const selected_image_src = image_panel.querySelector(\n                    `[name=tiptap-src][type=radio]:checked,\n                         [name=tiptap-src][type=checkbox]:checked,\n                         [name=tiptap-src][type=option]:checked,\n                         [name=tiptap-src][type=hidden],\n                         [name=tiptap-src][type=text],\n                         [name=tiptap-src][type=url]`\n                );\n\n                app.editor.commands.insertContent({\n                    type: \"figure\",\n                    content: [\n                        {\n                            type: \"image-figure\",\n                            attrs: {\n                                src: selected_image_src.value,\n                                ...(image_alt?.value && { alt: image_alt.value }),\n                                ...(image_title?.value && {\n                                    title: image_title.value,\n                                }),\n                            },\n                        },\n                        // Conditionally add a figcaption\n                        ...(image_caption?.value\n                            ? [\n                                  {\n                                      type: \"figcaption\",\n                                      content: [\n                                          {\n                                              type: \"text\",\n                                              text: image_caption.value,\n                                          },\n                                      ],\n                                  },\n                              ]\n                            : []),\n                    ],\n                });\n                if (set_focus === true) {\n                    // set cursor after the image, otherwise image is\n                    // selected and right away deleted when starting typing.\n                    app.editor.commands.selectParentNode();\n                    app.editor.commands.focus(app.editor.state.selection.to);\n                    //app.editor.commands.blur();\n                }\n            };\n\n            // FORM UPDATE\n            const form = dom.querySelectorAllAndMe(image_panel, \"form\")?.[0];\n            if (form) {\n                events.add_event_listener(form, \"submit\", \"tiptap_image_submit\", (e) => {\n                    // Prevent form submission when hitting \"enter\" within the form.\n                    // The form is handled by JS only.\n                    e.preventDefault();\n                });\n            }\n            if (image_confirm) {\n                // update on click on confirm\n                events.add_event_listener(\n                    image_confirm,\n                    \"click\",\n                    \"tiptap_image_confirm\",\n                    () => update_callback(true)\n                );\n            } else {\n                // update on input/change\n                for (const image_src of image_srcs) {\n                    events.add_event_listener(\n                        image_src,\n                        \"change\",\n                        \"tiptap_image_src\",\n                        update_callback\n                    );\n                }\n                events.add_event_listener(\n                    image_alt,\n                    \"change\",\n                    \"tiptap_image_alt\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    image_title,\n                    \"change\",\n                    \"tiptap_image_title\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    image_caption,\n                    \"change\",\n                    \"tiptap_image_caption\",\n                    update_callback\n                );\n            }\n        },\n\n        _node_image: null,\n        get node_image() {\n            // Get image node\n            if (this._node_image || this._node_image === undefined) {\n                return this._node_image;\n            }\n            this._node_image = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            return this._node_image;\n        },\n\n        _figcaption: null, // initialized as null. If not found this will be set to undefined.\n        get figcaption_node() {\n            // Return cached figcaption and avoid calling this method multiple times.\n            // Calling it again would select again a parent node which would lead to incorrect results.\n            if (this._figcaption || this._figcaption === undefined) {\n                return this._figcaption;\n            }\n\n            app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n            const node_figure = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            const node_figcaption = node_figure?.content.content.filter(\n                (it) => it.type.name === \"figcaption\"\n            )?.[0];\n            this._figcaption = node_figcaption; // if not found, this is undefined.\n            return node_figcaption;\n        },\n    };\n}\n\nexport function init({ app, button }) {\n    button.addEventListener(\"click\", () => {\n        if (dom.get_data(app.toolbar_el, \"tiptap-instance\", null) !== app) {\n            // If this pat-tiptap instance is not the one which was last\n            // focused, just return and do nothing.\n            // This might be due to one toolbar shared by multiple editors.\n            return;\n        }\n\n        // Register the image-panel pattern.\n        // Multiple registrations from different tiptap instances are possible\n        // since we're registering it only after the toolbar's image button has\n        // been clicked and clicking in another tiptap instance would override\n        // previous registrations.\n        const image_panel_pattern = image_panel({ app: app });\n        document.addEventListener(\n            \"patterns-injected-delayed\",\n            (e) => {\n                image_panel_pattern.init(e.detail.injected);\n\n                // Register listener on modal for any DOM changes done by pat-inject.\n                app.current_modal.addEventListener(\"patterns-injected-delayed\", () => {\n                    // Re-init panel after injection.\n                    image_panel_pattern.init(app.current_modal);\n                });\n            },\n            { once: true }\n        );\n    });\n\n    app.editor.on(\"selectionUpdate\", async () => {\n        app.editor.isActive(\"image-figure\")\n            ? button.classList.add(\"active\")\n            : button.classList.remove(\"active\");\n        app.editor.can().setImage()\n            ? button.classList.remove(\"disabled\")\n            : button.classList.add(\"disabled\");\n\n        if (app.options.image.menu) {\n            // Open the context menu with a small delay.\n            utils.debounce(async () => {\n                if (!app.editor.isActive(\"image-figure\")) {\n                    // Image not active anymore. Return.\n                    if (context_menu_instance) {\n                        // If open, close.\n                        await context_menu_close({\n                            instance: context_menu_instance,\n                            pattern_name: \"tiptap-image-context-menu\",\n                        });\n                        context_menu_instance = null;\n                    }\n                    return;\n                }\n\n                // Initialize the context menu\n                context_menu_instance = await context_menu({\n                    url: app.options.image.menu,\n                    editor: app.editor,\n                    instance: context_menu_instance,\n                    pattern: pattern_image_context_menu({ app: app }),\n                    extra_class: \"tiptap-image-menu\",\n                });\n            }, 50)();\n        }\n    });\n}\n\nexport const factory = () => {\n    return Node.create({\n        name: \"image-figure\",\n\n        addOptions() {\n            return {\n                HTMLAttributes: {},\n            };\n        },\n\n        addAttributes() {\n            return {\n                src: {\n                    default: null,\n                },\n                alt: {\n                    default: null,\n                },\n                title: {\n                    default: null,\n                },\n            };\n        },\n\n        group: \"block\",\n        inline: false,\n\n        allowGapCursor: false,\n        atom: true,\n        draggable: false,\n        isolating: true,\n        selectable: true,\n\n        parseHTML() {\n            return [\n                {\n                    tag: \"img\",\n                    getAttrs: (node) => node.closest(\"figure\") !== null && null, // prosemirror expects null for a successful check.\n                },\n            ];\n        },\n\n        renderHTML({ HTMLAttributes }) {\n            return [\"img\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n        },\n\n        addProseMirrorPlugins() {\n            return [\n                new Plugin({\n                    props: {\n                        handleDOMEvents: {\n                            dragstart: (view, event) => {\n                                // prevent drag/drop at all.\n                                event.preventDefault();\n                                return false;\n                            },\n                        },\n                    },\n                }),\n            ];\n        },\n    });\n};\n","import events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nexport const TARGETS = [];\n\nexport function focus_handler(el) {\n    // make element focusable\n    // See: https://javascript.info/focus-blur\n    el.setAttribute(\"tabindex\", \"-1\"); // not user-selectable but programmatically focusable.\n    events.add_event_listener(\n        el,\n        \"focus\",\n        \"tiptap-focusin\",\n        async () => {\n            utils.timeout(1); // short timeout to ensure focus class is set even if tiptap_blur_handler is called concurrently.\n            TARGETS.map((it) => it?.classList.add(\"tiptap-focus\"));\n        },\n        true\n    );\n    events.add_event_listener(\n        el,\n        \"blur\",\n        \"tiptap-focusout\",\n        () => {\n            TARGETS.map((it) => it?.classList.remove(\"tiptap-focus\"));\n        },\n        true\n    );\n}\n"],"names":["PREV_NODE","async","context_menu","url","editor","instance","pattern","extra_class","prev_node","cur_node","state","doc","nodeAt","selection","from","tippy","popperInstance","context_menu_close","pattern_name","name","get_content","registry","editor_element","options","element","patTooltip","events","reference_position","posToDOMRect","view","to","setProps","getReferenceClientRect","document","e","target","dom","includes","popper","key","show","hide","destroy","context_menu_instance","pattern_image_context_menu","app","Pattern","BasePattern","init","focus_handler","this","el","btn_edit","querySelector","btn_remove","addEventListener","toolbar","image","click","commands","selectParentNode","deleteSelection","focus","button","toolbar_el","image_panel_pattern","trigger","panel","image_panel","image_srcs","querySelectorAll","image_alt","image_title","image_caption","image_confirm","node_image","current_src","attrs","src","image_srcs_","filter","it","value","length","image_src","checked","dispatchEvent","type","title","alt","node_figcaption","figcaption_node","textContent","update_callback","set_focus","selected_image_src","insertContent","content","text","form","preventDefault","_node_image","undefined","_figcaption","detail","injected","current_modal","once","on","isActive","classList","add","remove","can","setImage","menu","utils","factory","Node","addOptions","HTMLAttributes","addAttributes","default","group","inline","allowGapCursor","atom","draggable","isolating","selectable","parseHTML","tag","getAttrs","node","closest","renderHTML","mergeAttributes","addProseMirrorPlugins","Plugin","props","handleDOMEvents","dragstart","event","TARGETS","setAttribute","map"],"sourceRoot":""}